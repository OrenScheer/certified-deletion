"""The circuit and associated methods that are used to decrypt a given ciphertext."""

from typing import Iterator, List, Tuple
from qiskit import ClassicalRegister, QuantumCircuit
from states import Basis, Key, Ciphertext
from encryption_circuit import calculate_error_correction_hash, calculate_privacy_amplification_hash, synd
from utils import xor, hamming_distance
import itertools


def create_decryption_circuit(key: Key, ciphertext: Ciphertext) -> QuantumCircuit:
    """Creates and returns the decryption circuit, given a Ciphertext and an associated Key."""
    decryption_circuit = ciphertext.circuit.copy()
    decryption_circuit.barrier()
    decryption_circuit.h(
        [i for i in range(decryption_circuit.num_qubits) if key.theta[i] is Basis.HADAMARD])
    decryption_circuit.measure_all()
    return decryption_circuit


def create_decryption_circuit_for_deletion(key: Key, ciphertext: Ciphertext) -> QuantumCircuit:
    """Creates and returns a decryption circuit where the deletion qubits are preserved, given a Ciphertext and Key."""
    decryption_circuit = ciphertext.circuit.copy()
    decryption_circuit.barrier()
    classical_register = ClassicalRegister(
        key.theta.count(Basis.COMPUTATIONAL))
    decryption_circuit.add_register(classical_register)
    decryption_circuit.measure([i for i in range(
        decryption_circuit.num_qubits) if key.theta[i] is Basis.COMPUTATIONAL], classical_register)
    return decryption_circuit


def generate_all_binary_strings(n: int) -> Iterator[str]:
    """Yields all binary strings of length n."""
    for tup in itertools.product("01", repeat=n):
        yield "".join(tup)


def corr(inp: str, syndrome: str) -> str:
    """Corrects a candidate input string to match the syndromes generated by the original string."""
    min_hamming_distance = float("inf")
    ans = ""
    for binary_string in generate_all_binary_strings(len(inp)):
        if synd(binary_string) == syndrome:
            if (this_hamming_distance := hamming_distance(inp, binary_string)) < min_hamming_distance:
                min_hamming_distance = this_hamming_distance
                ans = binary_string
    return ans


def corr_with_hash(inp: str, syndrome: str, ec_matrix: List[List[int]], ec_hash: str) -> str:
    """Corrects a candidate input string to match the syndromes and the error correction hash."""
    min_hamming_distance = float("inf")
    ans = ""
    for binary_string in generate_all_binary_strings(len(inp)):
        if synd(binary_string) == syndrome:
            if (this_hamming_distance := hamming_distance(inp, binary_string)) < min_hamming_distance:
                min_hamming_distance = this_hamming_distance
                ans = binary_string
            if calculate_error_correction_hash(ec_matrix, binary_string) == ec_hash:
                return binary_string
    return ans


def decrypt_results(measurements: dict[str, int], key: Key, ciphertext: Ciphertext, message: str, error_correct: bool = False) -> Tuple[int, int, int]:
    """Processes and decrypts the candidate decryption measurements for a sequence of experimental tests.

    Outputs relevant statistics.

    Args:
        measurements: A dictionary whose keys are the measurements of all the qubits by the receiving
            party once the key is revealed, and whose values are the number of times that each measurement
            string has occurred experimentally.
        key: The key to be used in the decryption circuit.
        ciphertext: The ciphertext that the receiving party possesses.
        message: The original plaintext, to compare with the candidate decryption.
        error_correct: Whether or not to apply the error correction procedure.

    Returns:
        A tuple (correct_count, incorrect_count, error_count) where correct_count is the number of
        correctly-decrypted messages, incorrect_count is the number of incorrectly-decrypted messages,
        and error_count is the number of times the decryption circuit raised an error flag.
    """
    correct_decryption_count = 0
    incorrect_decryption_count = 0
    errored_decryption_count = 0
    for measurement, count in measurements.items():
        if len(measurement) == key.theta.count(Basis.COMPUTATIONAL):
            # Only the computational basis qubits were measured
            relevant_bits = measurement
        else:
            # All the qubits were measured
            relevant_bits = "".join(
                [ch for i, ch in enumerate(measurement) if key.theta[i] is Basis.COMPUTATIONAL])
        if error_correct:
            relevant_bits = corr(relevant_bits, xor(ciphertext.q, key.e))
            # relevant_bits = corr_with_hash(relevant_bits, xor(
            #     ciphertext.q, key.e), key.error_correction_matrix, xor(ciphertext.p, key.d))
        error_corretion_hash = xor(calculate_error_correction_hash(
            key.error_correction_matrix, relevant_bits), key.d)
        if error_corretion_hash != ciphertext.p:
            errored_decryption_count += 1
        x_prime = calculate_privacy_amplification_hash(
            key.privacy_amplification_matrix, relevant_bits)
        decrypted_string = xor(ciphertext.c, x_prime, key.u)
        if decrypted_string == message:
            correct_decryption_count += count
        else:
            incorrect_decryption_count += count
    return correct_decryption_count, incorrect_decryption_count, errored_decryption_count
